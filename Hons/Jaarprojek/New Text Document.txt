When we call QApplication::exec(), we start Qt's event loop. Qt issues a few events on startup to show and paint the widgets. After that, the event loop is running, constantly checking to see if any events have occurred and dispatching these events to QObjects in the application.

While one event is being processed, additional events may be generated and appended to Qt's event queue. If we spend too much time processing a particular event, the user interface will become unresponsive. For example, any events generated by the window system while the application is saving a file to disk will not be processed until the file is saved. During the save, the application will not respond to requests from the window system to repaint itself.

One solution is to use multiple threads: one thread for the application's user interface and another thread to perform file saving (or any other time-consuming operation). This way, the application's user interface will stay responsive while the file is being saved. We will see how to achieve this in Chapter 17.

A simpler solution is to make frequent calls to QApplication::processEvents() in the file saving code. This function tells Qt to process any pending events, and then returns control to the caller. In fact, QApplication::exec() is little more than a while loop around a processEvents() function call.

Here's an example of how we can keep the user interface responsive using processEvents(), based on the file saving code for Spreadsheet (p. 77):

bool Spreadsheet::writeFile(const QString &fileName)
{
    QFile file(fileName);
    ...
    for (int row = 0; row < NumRows; ++row) {
        for (int col = 0; col < NumCols; ++col) {
            QString str = formula(row, col);
            if (!str.isEmpty())
                out << (Q_UINT16)row << (Q_UINT16)col << str;
        }
        qApp->processEvents();
    }
    return true;
}

One danger with this approach is that the user might close the main window while the application is still saving, or even click File|Save a second time, resulting in undefined behavior. The easiest solution to this problem is to replace the

qApp->processEvents();

call with a

qApp->eventLoop()->processEvents(QEventLoop::ExcludeUserInput);

call, which tells Qt to ignore mouse and key events.

Often, we want to show a QProgressDialog while a long running operation is taking place. QProgressDialog has a progress bar that keeps the user informed about the progress being made by the application. QProgressDialog also provides a Cancel button that allows the user to abort the operation. Here's the code for saving a Spreadsheet file using this approach:
