<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0046)http://www.cs.sun.ac.za/~eloff/rw314/tut1.html -->
<HTML><HEAD><TITLE>Computer Science 314 - Tutorial 1</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1"><LINK 
media=screen href="Computer Science 314 - Tutorial 1_files/style.css" 
type=text/css rel=stylesheet>
<META content="MSHTML 6.00.2800.1479" name=GENERATOR></HEAD>
<BODY bgColor=#ffffff background="">
<H1 align=left>Tutorial 1 - Display primitives</H1>
<H2 align=left>Motivation</H2>Developing system software can be frustrating at 
times. This is especially true when it becomes necessary to debug a module or 
group of modules. The problems associated with debugging system software can be 
attributed to the fact that there are no mechanisms in place to assist with the 
debugging process. The best way to obtain information is to examine the code 
generated by the compiler or assembler and by writing information to the display 
such as the contents of a register or variable. However, there is no operating 
system in place that is capable of offering display primitives to assist with 
debugging because you are still busy implementing it. In this tutorial you will 
be responsible for writing the necessary code to perform basic ouput on the 
display system. The module will later be replaced by a small I/O sub-system with 
support for virtual displays and has been designed so that it can be easily 
integrated with the project. 
<H2 align=left>Outcome</H2>If you have successfully completed this tutorial, you 

<UL>
  <LI>should have a basic understaning of the bootstrap process 
  <LI>should be familiar with how display memory in a basic PC workstation is 
  organized 
  <LI>should be familiar with how modules are compiled and linked to form a 
  single system that can be loaded by the bootstrap loader </LI></UL>
<H2 align=left>Background Information and Source Code</H2>Before continuing with 
the tutorial, make sure that you have familiarized yourself with the <A 
href="http://www.cs.sun.ac.za/~eloff/rw314/bootstrap2.pdf">bootstrap loader</A>, 
<A href="http://www.cs.sun.ac.za/~eloff/rw314/doc_display.html">display 
memory</A>, <A 
href="http://www.cs.sun.ac.za/~eloff/rw314/doc_BootLinker.html">bootlinker</A> 
and the <A 
href="http://www.cs.sun.ac.za/~eloff/rw314/doc_SYSTEM.html"><CODE>SYSTEM</CODE></A> 
module. You can obtain the source code for the basic system <A 
href="http://www.cs.sun.ac.za/~eloff/rw314/CS314.Arc">here</A></CODE>. Store the 
file in your <CODE>oberon</CODE> directory and then execute the command 
<CODE>Compress.ExtractAll CS314.Arc~</CODE> from within Oberon and open the 
<CODE>CS314.Tool</CODE> file. This file contains the necessary commands to 
compile and link the system. The <A 
href="http://www.cs.sun.ac.za/~eloff/rw314/boot.tar.gz">bootstrap loader's</A> 
source code must first be extracted using the command <CODE>tar -zxvf 
boot.tar.gz</CODE> before assembling it by executing the command <CODE>nasm -f 
bin boot.nasm</CODE>. If successful, a file called <I>boot</I> will be created 
that must be copied to your boot diskette by executing the command <CODE>dd 
if=boot of=/dev/fd0</CODE> from within a console. 
<H2 align=left>Instructions</H2>The following procedures must be implemented: 
<UL>
  <LI><B><CODE>PROCEDURE setfgcol(fgcol: LONGINT);</CODE></B><BR>Set the 
  foreground colour to <CODE>fgcol</CODE>. 
  <LI><B><CODE>PROCEDURE setbgcol(bgcol: LONGINT);</CODE></B><BR>Set the 
  background colour to <CODE>bgcol</CODE>. 
  <LI><B><CODE>PROCEDURE gotoxy(x, y: LONGINT);</CODE></B><BR>Set the current 
  screen position to the coordinates specified in <CODE>x</CODE> and 
  <CODE>y</CODE>. For example, <CODE>gotoXY(0, 0);</CODE> should set the screen 
  position to the top left corner while <CODE>GotoXY(79, 24)</CODE> should 
  specify the bottom right corner. 
  <LI><B><CODE>PROCEDURE ln</CODE></B><BR>Advance the current screen position to 
  the beginning of the next line. The screen position must wrap back to the top 
  of the display if <CODE>Ln</CODE> is executed on the bottom line of the 
  display. 
  <LI><B><CODE>PROCEDURE char(ch: CHAR);<CODE></B><BR>Writes a single attribute 
  and character to the display at the current screen position. Once written, the 
  screen position must be updated. If the end of the display (bottom right 
  corner) is reached, the display position should wrap back to the start (top 
  left corner) of the display. 
  <LI><B><CODE>PROCEDURE String*(s: ARRAY OF CHAR);</CODE></B><BR>Writes a 
  <CODE>0X</CODE> terminated character string to the display. 
  <LI><B><CODE>PROCEDURE Int*(val: LONGINT);</CODE></B><BR>Writes an integer 
  value to the display in decimal notation. 
  <LI><B><CODE>PROCEDURE Bin*(val: LONGINT);</CODE></B><BR>Writes an integer 
  value to the display in binary notation. 
  <LI><B><CODE>PROCEDURE Hex*(val: LONGINT);</CODE></B><BR>Writes an integer 
  value to the display in hexadecimal notation. 
  <LI><B><CODE>PROCEDURE Bit*(val, n: LONGINT);</CODE></B><BR>Writes a "1" to 
  the display if bit <CODE>n</CODE> of <CODE>val</CODE> is set, "0" otherwise. 
  <LI><B><CODE>PROCEDURE Mem*(address, n: LONGINT);</CODE></B><BR>Display 
  <CODE>n</CODE> bytes of memory, starting at <CODE>address</CODE>. The data 
  being displayed must be formatted so that each line being displayed starts 
  with a memory address, followed by up to sixteen bytes read from memory. For 
  example <CODE>Mem(501AH, 4)</CODE> should display something like <PRE>0000501A  F7 F8 EB D9
	     </PRE>while <CODE>Mem(501AH, 17)</CODE> should display something like <PRE>0000501A  F7 F8 EB D9 8B E5 5D C3 00 00 20 4F 00 00 00 00
0000502A  00
	     </PRE><B>Note that random values have been chosen for this example. When 
  reading from the aforementioned address, the byte sequence will probably be 
  different. The example is given to present the layout of the output and not 
  the physical contents of memory.</B> 
  <LI><B><CODE>PROCEDURE ClearDisplay*(attribute: LONGINT);</CODE></B><BR>Clears 
  the display using the specified display attribute and resets the screen 
  position to the top left corner. </LI></UL>Note that five procedure variables 
are used: <CODE>GotoXY</CODE>, <CODE>Char</CODE>, <CODE>Ln</CODE>, 
<CODE>SetFgCol</CODE> and <CODE>SetBgCol</CODE>. These procedure variables are 
initialized with the local implementations and will later be replaced by the 
output routine in the I/O sub-system. All other procedures should use the 
procedure variables (directly or indirectly). For example, <CODE>Int</CODE> 
should convert a numerical value into a character string that will be passed on 
as a parameter to <CODE>String</CODE> which in turn will call <CODE>Char</CODE> 
to display each character. If <CODE>Char</CODE> is later replaced with a new 
output routine, procedures such as <CODE>Int</CODE> and <CODE>Hex</CODE> should 
not require any modification. An outline of <CODE>osTrace</CODE> is presented 
below. <PRE>MODULE osTrace;

IMPORT
  SYSTEM, osBootTable;
	
CONST
  (** Colour attributes for background *)
  bgBlack* = 0;
  bgBlue* = 1;
  bgGreen* = 2;
  bgCyan* = 3;
  bgRed* = 4;
  bgMagenta* = 5;
  bgBrown* = 6;
  bgGrey* = 7;

  (** Colour attributes for foreground *)
  fgBlack* = 0;
  fgBlue* = 1;
  fgGreen* = 2;
  fgCyan* = 3;
  fgRed* = 4;
  fgMagenta* = 5;
  fgBrown* = 6;
  fgGrey* = 7;
  fgDarkGrey* = 8;
  fgLightBlue* = 9;
  fgLightGreen* = 10;
  fgLightCyan* = 11;
  fgLightRed* = 12;
  fgLightMagenta* = 13;
  fgYellow* = 14;
  fgWhite* = 15;

VAR
  DisplayBase: LONGINT;
	
  (** Procedure variables for basic display primitives. These variables will later be
      remapped to the primitives in osTTY *)
  Char*: PROCEDURE (ch: CHAR);
  GotoXY*: PROCEDURE (x, y: LONGINT);
  SetFgCol*: PROCEDURE (fgcol: LONGINT);
  SetBgCol*: PROCEDURE (bgcol: LONGINT);
  Ln*: PROCEDURE;
	
  (* I/O address for display adapter's address register *)
  regAddress: LONGINT;
	
PROCEDURE gotoxy(x, y: LONGINT);
END gotoxy;

PROCEDURE setfgcol(fgcol: LONGINT);
END setfgcol;

PROCEDURE setbgcol(bgcol: LONGINT);
END setbgcol;

PROCEDURE char(ch: CHAR);
END char;

PROCEDURE ln;
END ln;

PROCEDURE String*(s: ARRAY OF CHAR);
END String;

PROCEDURE Int*(val: LONGINT);
END Int;

PROCEDURE Bin*(val: LONGINT);
END Bin;

PROCEDURE Bit*(val, n: LONGINT);
END Bit;

PROCEDURE Hex*(val: LONGINT);
END Hex;

PROCEDURE Mem*(address, n: LONGINT);
END Mem;

PROCEDURE ClearDisplay*;
END ClearDisplay;

BEGIN
  (* Read the linear base address for the display adapter from the boot table *)
  DisplayBase := osBootTable.Entry(osBootTable.btDisplayBaseAddress);
  (* For MDA adapter, registers are located at 3B4H and 3B5H. Colour displays normally use 
     3D4H and 3D5H *)
  regAddress := osBootTable.Entry(osBootTable.btDisplayAddressRegister);
  (* Initialize procedure variables *)
  Char := char; GotoXY := gotoxy; Ln := ln; SetFgCol := setfgcol; SetBgCol := setbgcol
END osTrace.
      </PRE>
<UL>
  <LI>Store the module as <B><CODE>osTrace.Mod</CODE></B>. 
  <LI>Compile the module, then link it using the static linker. 
  <LI>Write the file to disk by executing the command <B><CODE>dd if=trace 
  of=/dev/fd0 seek=18 bs=512</CODE></B> from inside the <CODE>oberon</CODE> 
  directory using a console. The <B><CODE>dd</CODE></B> command (Copy and 
  Convert file) copies the file specified as input (<B><CODE>if</CODE></B> 
  parameter) to the file specified as output (<B><CODE>of</CODE></B> parameter). 
  The <B><CODE>seek</CODE></B> parameter instructs the command to skip the first 
  18 blocks before writing to the output file. The last parameter, 
  <B><CODE>bs</CODE></B>, tells <B><CODE>dd</CODE></B> the size of a single 
  block. The output file <B><CODE>/dev/fd0</CODE></B> refers to the first floppy 
  disk device (Other systems such as Windows and MS-DOS usually refer to this 
  device as <B><CODE>A:</CODE></B>). For more information on 
  <B><CODE>dd</CODE></B>, refer to the man pages or info pages by executing the 
  command <B><CODE>man dd</CODE></B> or <B><CODE>info dd</CODE></B> from the 
  command prompt in Linux. </LI></UL>
<H2 align=left>Optional</H2>
<UL>
  <LI>Program the cursor location registers so that the position of the cursor 
  is automatically updated after a call to <CODE>osTrace</CODE>. The <A 
  href="http://www.cs.sun.ac.za/~eloff/rw314/doc_SYSTEM.html"><CODE>SYSTEM</CODE></A> 
  module contains two procedures (<CODE>PORTIN</CODE> and <CODE>PORTOUT</CODE>) 
  that can be used to access the display adapter's internal register set. 
  <LI>Modify the routines so that the display is scrolled up instead of wrapping 
  to the beginning of the display. </LI></UL>
<H2 align=left>Testing</H2>Write a separate test module that contains all your 
test cases for each output primitive. Remember that the trace module will later 
be used to assist you with debugging other modules, so it is important to ensure 
that it is working correctly. If the trace module contains errors, then the rest 
of your debugging efforts will be unsuccessful (you will be trying to locate 
errors using invalid results). The following list contains some ideas that you 
can use in developing your test cases and shows you how to apply them to ensure 
that your software works: 
<UL>
  <LI>Prepare a number of boundary test cases (test cases where the input falls 
  on both the upper and lower boundary of valid inputs). For example, consider 
  the <CODE>Int</CODE> routine. This routine accepts a variable of type 
  <CODE>LONGINT</CODE> as parameter, so boundary testing will require that the 
  values <CODE>MAX(LONGINT)</CODE> and <CODE>MIN(LONGINT)</CODE> be used as 
  input. Other boundary values typically include -1, 0 and 1. Similar boundary 
  test cases can be developed for other data types such as character strings and 
  <CODE>SET</CODE>s. 
  <LI>Prepare a number of general test cases. 
  <LI>Prepare a number of test cases that are invalid. For example, consider the 
  <CODE>String</CODE> routine. An invalid test case would be a string that is 
  not properly terminated (no <CODE>0X</CODE> character). This type of error 
  will usually be detected by Oberon (Index out of bounds), but since there is 
  no system to detect runtime errors, explicit tests must be built into the 
  system. Keeping with the aforementioned example, once the index variable used 
  to obtain the next character from the string is equal to the physical array 
  length, then it can be assumed that the string was not properly terminated. 
  <LI>Coverage analysis tells us what percentage of code have been tested. 
  Software often contains multiple execution paths that divide and meet again 
  later in a program. Consider the following code excerpt: <PRE>IF (a = 2) OR (b = 3) THEN
  c = 4
END;
d := a+b+c;
	     </PRE>In this example, there are four possible cases that take us to the 
  last statement, <CODE>d := a+b+c;</CODE>: 
  <OL>
    <LI>Both <CODE>a</CODE> and <CODE>b</CODE> can force the <CODE>IF</CODE> 
    statement to evaluate to false (<CODE>a=1</CODE> and <CODE>b=2</CODE>) 
    <LI>The sub-expression <CODE>a=2</CODE> could be true while the 
    sub-expression <CODE>b=3</CODE> could be false 
    <LI>The sub-expression <CODE>b=3</CODE> could be true while the 
    sub-expression <CODE>a=2</CODE> could be false 
    <LI>Both sub-expressions could evaluate to true </LI></OL>Although multiple 
  condition coverage is the ideal (every combination for every expression and 
  sub-expression evaluating to true and false have been tested), it is seldom 
  achieved in the software industry. Branch coverage, where every expression 
  have been tested to evaluate to true and false, is usually the minimum one 
  should strive to obtain. Keeping with our example, the following two cases 
  will ensure 100% branch coverage (50% multiple condition coverage): 
  <OL>
    <LI><CODE>a=2</CODE> will ensure that the <CODE>IF</CODE> statement 
    evaluates to true 
    <LI><CODE>a=1</CODE> and <CODE>b=2</CODE> will ensure that the 
    <CODE>IF</CODE> statement evaluates to false </LI></OL>
  <LI>Remember to run all your test cases whenever you modify code that was 
  previously tested. NEVER assume it will still work! Case studies in industry 
  have shown that the smallest changes in large software systems often result in 
  the highest maintainance cost relative to the whole system because software 
  engineers neglect to test the system after making small modifications. 
</LI></UL>
<H2 align=left>Testing <CODE>osTrace</CODE></H2>To test <CODE>osTrace</CODE>, a 
separate module should be developed, for example: <PRE>MODULE TestTrace;

IMPORT
  osTrace;
  
BEGIN
  (* Insert test cases here *)
  LOOP END
END TestTrace.
      </PRE>Compile this module and add it to the list of modules specified as 
parameters to the linker: <PRE>BootLinker.Link os314
  \list osModules.modules
  \mdesc osModules.ModuleDesc
  \expdesc osModules.ExportDesc
  \integrate 1000H
  osModules osBootTable osTrace TraceTest ~
      </PRE>Note that the module contains a <CODE>LOOP END</CODE> statement at 
the end. The reason for this is that there are no other instructions in memory 
to execute (Remember, your image will be the only executable code inside RAM) 
after the last test case. 
<HR>

<ADDRESS></ADDRESS></CODE></CODE></BODY></HTML>
