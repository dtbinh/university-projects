<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0046)http://www.cs.sun.ac.za/~eloff/rw314/tut2.html -->
<HTML><HEAD><TITLE>Computer Science 314 - Tutorial 2</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1"><LINK 
media=screen href="Computer Science 314 - Tutorial 2_files/style.css" 
type=text/css rel=stylesheet>
<META content="MSHTML 6.00.2800.1479" name=GENERATOR></HEAD>
<BODY bgColor=#ffffff background="">
<H1 align=left>Tutorial 2 - Introduction to interrupt handling</H1>
<H2 align=left>Motivation</H2>The processing of interrupts is an important 
function of operating and control systems because most devices interact with the 
system through this mechanism. This tutorial serves as an introduction to 
interrupt processing on PCs and deals with the 8259 <I>programmable interrupt 
controller</I> (PIC) that is responsible for managing the interrupt signals 
received from certain peripherals such as the system clock, keyboard, disk 
drives en network cards. 
<P>It is important to manage interrupts efficiently because it will increase the 
amount of CPU time that can be allocated to user processes. Certain software 
mechanisms must also be in place to accomplish this. The most imporant mechanism 
is the </I>interrupt descriptor table</I> (IDT). This table contains the 
information associated with every interrupt handler and will be accessed by the 
CPU whenever it decides to process an interrupt signal from a hardware device or 
executes a software interrupt instruction (<CODE>INT</CODE>). The operating 
system must also provide a good abstraction of the hardware and provide the 
necessary mechanisms to manage the installation and removal of interrupt 
handlers. 
<H2 align=left>Outcomes</H2>If you have successfully completed this tutorial, 
you 
<UL>
  <LI>should have a basic understanding of how the IDT works in resolving 
  interrupts and invoking the appropriate handler 
  <LI>should be familiar with the 8259A interrupt controller that is responsible 
  for managing hardware interrupts on the PC </LI></UL>
<H2 align=left>Background Information</H2>Before continuing with the tutorial, 
make sure that you have familiarized yourself with the <A 
href="http://www.cs.sun.ac.za/~eloff/rw314/doc_8259.html">8259A (PIC)</A>, the 
IDT (Sections 1.5 to 1.5.2 from the notes that discuss the protected mode model) 
and the <A 
href="http://www.cs.sun.ac.za/~eloff/rw314/doc_SYSTEM.html"><CODE>SYSTEM</CODE></A> 
module. Additional source code will be provided and can be downloaded <A 
href="http://www.cs.sun.ac.za/~eloff/rw314/Tut2.Arc">here</A>. 
<P>The <CODE>SET</CODE> operations provided by <I>Oberon</I> makes bit picking 
fairly easy and a solid understanding will be essential to complete this 
tutorial successfully. Communication with the hardware through the various I/O 
ports can be accomplished by using the <B><CODE>SYSTEM.PORTIN</CODE></B> and 
<B><CODE>SYSTEM.PORTOUT</CODE></B> procedures. 
<P>Care should be taken to ensure that the size of the second operand of the 
<CODE>PORTIN</CODE> and <CODE>PORTOUT</CODE> procedures correspond with the I/O 
port's width (size). The <CODE>PORTOUT</CODE> procedure translates to an 
<CODE>OUT</CODE> machine instruction while <CODE>PORTIN</CODE> translates to an 
<CODE>IN</CODE> instruction. Both these instructions each support 8-bit, 16-bit 
and 32-bit operands. The compiler examines the type of the second parameter of 
<CODE>PORTOUT</CODE> and <CODE>PORTIN</CODE> to determine whether an 8-bit, 
16-bit or 32-bit operand is used by the machine instruction. Use the 
<CODE>SYSTEM.VAL</CODE> operation to ensure that the operand size and port size 
match, for example: <PRE>VAR
  port, value: LONGINT;
...
SYSTEM.PORTOUT(port, SYSTEM.VAL(CHAR, value))
...
    </PRE>The table below lists the I/O instructions generated by the compiler 
for different basic types when using <CODE>PORTINT</CODE> and 
<CODE>PORTOUT</CODE>. 
<P>
<TABLE cellSpacing=2 width="50%" border=0>
  <TBODY>
  <TR>
    <TD align=middle bgColor=#c0c0c0>TYPE (2nd Parameter)</TD>
    <TD align=middle bgColor=#c0c0c0><CODE>PORTIN</CODE></TD>
    <TD align=middle bgColor=#c0c0c0><CODE>PORTOUT</CODE></TD></TR>
  <TR>
    <TD align=middle bgColor=#ded5d3><CODE>CHAR</CODE></TD>
    <TD align=middle bgColor=#ded5d3><CODE>IN AL,DX</CODE></TD>
    <TD align=middle bgColor=#ded5d3><CODE>OUT DX,AL</CODE></TD></TR>
  <TR>
    <TD align=middle bgColor=#ded5d3><CODE>SHORTINT</CODE></TD>
    <TD align=middle bgColor=#ded5d3><CODE>IN AL,DX</CODE></TD>
    <TD align=middle bgColor=#ded5d3><CODE>OUT DX,AL</CODE></TD></TR>
  <TR>
    <TD align=middle bgColor=#ded5d3><CODE>INTEGER</CODE></TD>
    <TD align=middle bgColor=#ded5d3><CODE>IN AX,DX</CODE></TD>
    <TD align=middle bgColor=#ded5d3><CODE>OUT DX,AX</CODE></TD></TR>
  <TR>
    <TD align=middle bgColor=#ded5d3><CODE>LONGINT</CODE></TD>
    <TD align=middle bgColor=#ded5d3><CODE>IN EAX,DX</CODE></TD>
    <TD align=middle bgColor=#ded5d3><CODE>OUT DX,EAX</CODE></TD></TR>
  <TR>
    <TD align=middle bgColor=#ded5d3><CODE>SET</CODE></TD>
    <TD align=middle bgColor=#ded5d3><CODE>IN EAX,DX</CODE></TD>
    <TD align=middle bgColor=#ded5d3><CODE>OUT 
DX,EAX</CODE></TD></TR></TBODY></TABLE>
<H2 align=left>Instructions</H2>An outline for the 8259A driver is provided in 
module <B><CODE>os8259.Mod</CODE></B> and you must complete the following 
procedures: 
<UL>
  <LI><B><CODE>PROCEDURE InstallInterruptHandler*(int: LONGINT; adr: 
  InterruptHandler; userlevel: BOOLEAN): BOOLEAN;</CODE></B><BR>This function 
  will be used to install an interrupt handler for the interrupt specified in 
  parameter <B><CODE>int</CODE></B>. The function must return 
  <B><CODE>TRUE</CODE></B> if the installation was successful, otherwise it must 
  return <B><CODE>FALSE</CODE></B>. The IMR of either the primary or secondary 
  PIC must be modified if an interrupt handler for a hardware device is being 
  installed. The <B><CODE>userlevel</CODE></B> parameter is used by 
  <CODE>osMachine</CODE> to determine the privilege level of the handler's 
  descriptor in the IDT. 
  <LI><B><CODE>PROCEDURE RemoveInterruptHandler*(int: LONGINT; process: 
  BOOLEAN): BOOLEAN;</CODE></B><BR>This function will be used to remove an 
  interrupt handler previously installed with 
  <B><CODE>InstallInterruptHandler</CODE></B> and must return 
  <B><CODE>TRUE</CODE></B> if the operation was successful and 
  <B><CODE>FALSE</CODE></B> if unsuccessful. The IMR of either the primary or 
  secondary PIC must be adjusted to inhibit interrupts if a handler associated 
  with a hardware device is being removed. 
  <LI><B><CODE>PROCEDURE Initialize8259A;</CODE></B><BR>This procedure will 
  intialize the 8259 programmable interrupt controller by writing the necessary 
  control words to both the primary and secondary controllers. </LI></UL>Once you 
have completed the four procedures you may test your module by performing the 
following tasks: 
<UL>
  <LI>Compile all the modules, then link them using the static linker. Remember 
  to add all the source code files to the list in <CODE>CS314.Tool</CODE>. The 
  object code for a small clock driver is provided in 
  <B><CODE>osTimer.Obj</CODE></B> to test your implementation. The command line 
  for the linker should look as follows: BootLinker.Link os314 <PRE>BootLinker.Link os314
\list osModules.modules
\mdesc osModules.ModuleDesc
\expdesc osModules.ExportDesc
\integrate 1000H
osModules osBootTable osTrace osMachine os8259 osExceptions osTimer osInit ~
	   </PRE><B>Make sure that <CODE>osTrace</CODE> follows the interface 
  definition that was specified in tutorial 1. If this interface is not 
  followed, then the system will not link successfully.</B> 
  <LI>Write the file to disk by using the command <B><CODE>dd if=os314 
  of=/dev/fd0 seek=18 bs=512</CODE></B>. The <B><CODE>dd</CODE></B> command 
  (Copy and Convert file) copies the file specified as input 
  (<B><CODE>if</CODE></B> parameter) to the file specified as output 
  (<B><CODE>of</CODE></B> parameter). The <B><CODE>seek</CODE></B> parameter 
  instructs the command to skip the first 18 blocks before writing to the output 
  file. The last parameter, <B><CODE>bs</CODE></B>, tells <B><CODE>dd</CODE></B> 
  the size of a single block. The output file <B><CODE>/dev/fd0</CODE></B> 
  refers to the first floppy disk device (Other systems such as Windows and 
  MS-DOS refers to this device as <B><CODE>A:</CODE></B>). For more information 
  on <B><CODE>dd</CODE></B>, refer to the man pages or info pages by executing 
  the command <B><CODE>man dd</CODE></B> or <B><CODE>info dd</CODE></B> from the 
  command prompt in Linux. 
  <LI>If the system is working, a running counter should appear on the display. 
  The counter is incremented every 20ms. </LI></UL>
<ADDRESS></ADDRESS></BODY></HTML>
