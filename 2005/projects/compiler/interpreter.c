/****************************************************************
 * 	interpreter.c						*
 *								*
 * 	Part of Software design: Compiler project (2005)	*
 *								*
 * 	Group: Andrew Mori, Eduard Bergh, Mia Meyer Abrie Greef *
 ****************************************************************/

/*
* R28 is used to keep track of which registers are currently being used.
* R31 is used to store the return adress of branch instructions
*
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "include/opcodes.h"
#include "include/asm.h"
#include "include/types.h"
#include "include/codegen.h"

#ifdef DEBUG_INTERP
	#define print(x, ...) printf(x, ## __VA_ARGS__)
#else
	#define print(x, ...)
#endif
#ifdef DEBUG_INTERP_INSTR
	#define printi(x, ...) printf(x, ## __VA_ARGS__)
#else
	#define printi(x, ...)
#endif

#define MEM_SIZE 1024*1024


// control unit : program counter & instruction register
unsigned long PC, IR;
// arithmetic unit : registers 0 - 31
long R[32];
// memory
long memory[MEM_SIZE/4];
// buffer for reading strings from text file
unsigned long buffer, pc0;
// file to read from
FILE *fptr;
// index holder of current instruction in memory
int ms;

//if stack printing is enabled
int stackPrinting;

// prototype for forward referencing
void printmem();

/*
* loadFile()
*
* Description : Loads the file containing the instructions generated by the code generator and reads them into memory.
*
* Input : NONE
* Output : NONE
*
*/

void loadFile(char *file) {

	int i;
	fptr = fopen(file, "r");
	
	i = 0;
  
	if (fptr == NULL) {
		printf("\nError reading file received from code generator\n\n");
		exit(1);
	}
  
	fread(&R[30],sizeof(long),1,fptr);
	R[30] = R[30] / 4;
	fread(&R[29],sizeof(long),1,fptr);
	R[29] = R[29]/4;
	
	fread(&pc0,sizeof(long),1,fptr);
	
	while ((fptr != NULL) && (feof(fptr) == 0)) {
		fread(&memory[i],sizeof(buffer),1,fptr);
		i++;
	}
  
	fclose(fptr);
}

/*
 * getValues()
 *
 * Description : Retrieves the values in the opcodes.
 *
 * Input : unsigned long code : the opcode to process
 *  	   unsigned long a, b : pointers to the a and b values to be retrieved from the opcode
 *	   long c : pointer to the c value to be retrieved from the opcode
 * Output : Reference pointers to the values to be retreived
 *
*/

void getValues(unsigned long *code, unsigned long *a, unsigned long *b, long *c) {

	// gets the opcode number  
	buffer = memory[PC];
	*code = (unsigned long) (buffer>>26);
  
	if ((*code > NO_CODE)&&(*code <= F1_RD)) {
		printi("code of type F1 = %s\n", getOpString(*code));
		*a = (buffer<<6)>>27;
		*b = (buffer<<11)>>27;
		*c = (buffer<<16)>>16;
		if (bt(*c,15)) {
			btr(*c,15);
			*c = -*c;
		}
		printi("a = %lu  b = %lu  c = %ld\n", *a, *b, *c);
	}
	else if ((*code >= F2_ADDI)&&(*code <= F2_RET)) {
		printi("code of type F2 = %s\n", getOpString(*code));
		*a = (buffer<<6)>>27;
		*b = (buffer<<11)>>27;
		*c = (buffer<<16)>>16;
		if (bt(*c,15)) {
			btr(*c,15);
			*c = -*c;
		}
		printi("a = %lu  b = %lu  c = %ld\n", *a, *b, *c);
	}
	else if (*code >= F3_JSR) {
		printi("code of type F3 = %s\n",getOpString(*code));
		*c = (buffer<<6)>>6;
		if (bt(*c,25)) {
			btr(*c,25);
			*c = -*c;
		}
		printi("c = %ld\n", *c);
	}
	else {
		printf("Not a valid code constant\n");
	}
}

/*
 * getMemSize()
 *
 * Description : Returns the amount of memory allocated in the memory array
 *
 * Input : NONE
 * Output : Integer representing the size of the allocated memory
 *
*/

int getMemSize() {

	int i;
	i = 0;

	while (memory[i] != 0) {
		i++;
	}
	print("memsize : %d\n", i);
	return i;
}

/*
 * print_reg()
 *
 * Description : Prints the state of the register array to screen
 *
 * Input : NONE
 * Output : NONE
 *
*/

void print_reg() {
	unsigned int i;
	printf("Register contents\n");
	  
	for (i = 0; i < (sizeof(R)/4); i++) {
		if (R[i] != 0) {
			printf("R[%d] = %ld\n", i, R[i]);
		}
	}
}

/*
 * printStack()
 *
 * Description : Prints the state of the memory array to screen
 *
 * Input : NONE
 * Output : NONE
 *
*/

void printStack() {
	int i;
	printf("Current stack state\n");
	printf("Stack size %ldKB\n",(MEM_SIZE - R[30]*4));
	for (i = R[30]; i < MEM_SIZE/4; i++) {
		printf("memory[%d] : %ld\n", i, memory[i]);
	}
}

/*
 * execute()
 *
 * Description : This is the main function of the interpreter. It processes the instructions and allocates values to the
 * appropriate registers and memory slots executing the opcodes one at a time. The function loops through all the opcodes
 * until either the F2_RET instruction is encountered or a runtime error occurs.
 *
 * Input : NONE
 * Output : NONE
 *
*/

void execute() {

	unsigned long opcode;
	unsigned long a, b, next;
	long c;
	int i;
  
	R[31] = 0;
	PC = pc0;
	i = 0;
	ms = getMemSize();

	while (TRUE) {
		if (R[30] <= (long)PC) {
			printf("Runtime error: Stack overflow\n");
			return;
		}
		getValues(&opcode,&a,&b,&c);
	
		next = PC + 1;
		IR = memory[PC];
	
		switch(opcode) {
			case F1_ADD : R[a] = R[b] + R[c];
				printi("ADD\n");
				break;
				
			case F1_SUB : R[a] = R[b] - R[c];
				printi("SUB\n");
				break;
				
			case F1_MUL : R[a] = R[b]*R[c];
				printi("MUL\n");
				break;
				
			case F1_DIV :
				printi("DIV\n");
				if (R[c] == 0) {
					printf("Runtime error: Division by zero\n");
					delay(12000);
					return;
				}
				R[a] = R[b]/R[c];
				break;
				
			case F1_MOD : R[a] = R[b]%R[c];
				printi("MOD\n");
				break;
				
			case F1_CMP : R[a] = R[b] - R[c];
				printi("CMP\n");
				break;
				
			case F1_CHK :printi("CHK\n");
				if ((R[a] < 0)||(R[a] >= R[c])) {
					printf("Runtime error: Array index out of bounds\n");
					return;
				}
				break;
				
			case F1_AND : R[a] = R[b]&R[c];
				printi("AND\n");
				break;
				
			case F1_OR : R[a] = R[b]|R[c];
				printi("OR\n");
				break;
				
			case F1_LSH :
				if (R[c] >= 0) {
					R[a] = R[b]<<R[c];
				}
				else R[a] = R[b]>>R[c];
				printi("LSH\n");
				break;
				
			case F1_ASH :
				// R[b] == 0 makes no difference
				if (R[c] >= 0) {
					R[a] = R[b]<<R[c];
				}
				else {
					R[a] = R[b]>>R[c];
					R[a] = R[a]*(-1);
				}
				printi("ASH\n");
				break;
				
			case F1_LDW : print("R[a] = %ld, R[b] = %ld, c = %ld %ld,%ld,%ld\n",R[a],R[b],c/4,a,b,c);
				R[a] = memory[R[b] + c/4];
				print("R[a] = %ld, R[b] = %ld, c = %ld\n",R[a],R[b],c/4);
				printi("LDW\n");
				break;
				
			case F1_LDB : R[a] = memory[R[b] + c/4];
				break;
			
			case F1_STW : memory[R[b] + c/4] = R[a];
				print("R[a]=%ld mem[R[b] + c)/4]=%d (R[b] + c)/4=%d\n",R[a],memory[(R[b] + c)/4],(R[b] + c)/4);
				printi("STW\n");
				break;
				
			case F1_STB : memory[R[b] + c] = R[a];
				break;
				
			case F1_POP : R[a] = memory[R[b]];
				R[b] = R[b] + c/4;
				print("POP c = %ld\n",R[a]);
				printi("POP\n");
				break;
				
			case F1_PSH :
				print("R[a]=%ld mem[R[b] + c/4]=%ld R[b] = %ld, a = %ld, b = %ld, c = %ld\n",R[a],memory[R[b] + c/4] ,R[b],a ,b, c);
				R[b] = R[b] - c/4;
				memory[R[b]] = R[a];
				print("R[a]=%ld mem[R[b] + c/4]=%ld R[b] = %ld, a = %ld, b = %ld, c = %ld\n",R[a],memory[R[b] + c/4] ,R[b],a ,b, c);
				printi("PUSH\n");
				break;
				
			case F1_BEQ :
				if (R[a] == R[b]) {
					next = PC + c;
					if (c == 0) {
						printf("Runtime error: All guards evaluated to false\n");
						return;
					}
				}
				printi("BEQ\n");
				break;
				
			case F1_BNE :
				if (R[a] != R[b]) {
					next = PC + c;
					if (c == 0) {
						printf("Runtime error: All guards evaluated to false\n");
						return;
					}
				}
				printi("BNE\n");
				break;
				
			case F1_BLT :
				if (R[a] < R[b]) {
					next = PC + c;
					if (c == 0) {
						printf("Runtime error: All guards evaluated to false\n");
						return;
					}
				}
				printi("BLT\n");
				break;
				
			case F1_BGE :
				if (R[a] >= R[b]) {
					next = PC + c;
					if (c == 0) {
						printf("Runtime error: All guards evaluated to false\n");
						return;
					}
				}
				printi("BGE\n");
				break;
				
			case F1_BGT :
				if (R[a] > R[b]) {
					next = PC + c;
					if (c == 0) {
					printf("Runtime error: All guards evaluated to false\n");
					return;
					}
				}
				printi("BGT\n");
				break;
				
			case F1_BLE :
				if (R[a] <= R[b]) {
					next = PC + c;
					if (c == 0) {
						printf("Runtime error: All guards evaluated to false\n");
						return;
					}
				}
				printi("BLE\n");
				break;
				
			case F1_BSR :
				R[31] = PC+1;
				print("\t\tnext = %d\n",next);
				next = c;
				printi("BSR\n");
				break;
				
			case F2_ADDI : R[a] = R[b] + c;
				print("ADDI %d %d %d\n",R[a],R[b],c);
				printi("ADDI\n");
				break;
				
			case F2_SUBI : R[a] = R[b] - c;
				printi("SUBI\n");
				break;
				
			case F2_MULI : R[a] = R[b]*c;
				printi("MULI\n");
				break;
				
			case F2_DIVI : R[a] = R[b]/c;
				printi("DIVI\n");
				break;
				
			case F2_MODI : R[a] = R[b]%c;
				printi("MODI\n");
				break;
				
			case F2_CMPI : R[a] = R[b] - c;
				printi("CMPI\n");
				break;
				
			case F2_CHKI : 
				if ((R[a] < 0)||(R[a] >= c)) {
					printf("Runtime error: Array index out of bounds\n");
					return;
				}
				printi("CHKI\n");
				break;
				
			case F2_ANDI : R[a] = R[b]&c;
				printi("ANDI\n");
				break;
				
			case F2_ORI : R[a] = R[b]||c;
				printi("ORI\n");
				break;
				
			case F2_LSHI :
				if (c > 0) {
					R[a] = R[b]<<c;
				}
				else R[a] = R[b]>>c;
				printi("LSHI\n");
				break;
				
			case F2_ASHI :
				// c == 0 makes no difference
				if (c >= 0) {
					R[a] = R[b]<<c;
				}
				else {
					R[a] = R[b]>>c;
					R[a] = R[a]*(-1);
				}
				printi("ASHI\n");
				break;
				
			case F2_RET :
				// jump to address R[c] (F2, absolute address)
				next = R[c];
				if (R[c] == 0) {
					return ;
				}
				print("R[c] = %ld\n",R[c]);
				printi("RET\n");
				break;
				
			case F3_JSR :
				// save PC in R31, then jump to c (F3, absolute address)
				R[31] = PC;
				next = PC + c/4;
				printi("JSR\n");
				break;
				
			case F3_WRD :
				printi("WRD\n");
				print("PC = %d\n",PC);
				print("WRD:value in register %ld = %ld\n", c, R[c]);
				printf("%ld\n",R[c]);
				break;
				
			case F1_RD:
				printi("RD\n");
				scanf("%ld",&R[a]);
				memory[R[b]+c/4] = R[a];
				break;
				
			default : print("not a valid opcode - interpreter.c\n");
				break;
		}
		i++;
		
		PC = next;
		
		if (stackPrinting == TRUE) {
			printf("_____________\n");
			print_reg();
			printf("=============\n");
			printStack();
			printf("*************\n");
			delay(700);
		}
	}

}

/*
 * printmem()
 *
 * Desription : prints the state of the memory array to the stack
 *
 * Input : NONE
 * Output : NONE
 *
*/

void printmem() {

	int i;

	for (i = 0; i < ms; i++) {
		if (memory[i] != 0) {
			print("memory[%d] : %lu\n", i, memory[i]);
		}
	}
  
	for (i = ms; i < MEM_SIZE/4; i++) {
		if (memory[i] != 0) {
			printf("memory[%d] : %ld\n", i, memory[i]);
		}
	}
}

/*
 * init_mem()
 *
 * Description : Initialises the memory array by setting all the equal entries to zero.
 *
 * Input : NONE
 * Output : NONE
 *
*/

void init_mem() {

	int i;
 	stackPrinting = FALSE;
	for (i = 0; i < (MEM_SIZE/4); i++) {
		memory[i] = 0;
	}
}

/*
 * main()
 *
 * Description : This is the first funtion that is called when this module is executed. It calls the functions to initialise the
 * memory, load the file and execute the instructions
 *
 * Input : NONE
 * Output : Integer that has to be returned (required by C compiler)
 *
*/

int main(int argc,char **argv) {

	init_mem();
	if ((argc != 2) && (argc != 3)) {
		printf("Usage rcp [-stack] <filename>\n\t<filename> file to run\n");
		printf("\t-stack : optional parameter to enable stack printing\n");
	}
	else {
		if (argc == 3) {
			if (strcmp(argv[1],"-stack") != 0) {
				printf("Invalid parameter %s\n",argv[1]);
				exit(1);
			}
			else {
				stackPrinting = TRUE;
				printf("Switching on stack printing\n");
			}
		}
		loadFile(argv[argc-1]);
		printf("Executing program...\n");
		execute();
		
	}
	return 0;
  
}
