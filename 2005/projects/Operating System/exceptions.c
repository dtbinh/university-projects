/*
 *        MODULE: exceptions.c
 *   DESCRIPTION: This module provides a mechanism to handle exceptions
 *                generated by the processor.
 *        AUTHOR: Jacques Eloff
 *                University of Stellenbosch
 *                eloff@cs.sun.ac.za
 * LAST MODIFIED: 27.01.2005
 *     CHANGELOG:
 *                27.01.2005 - Added diagnostic messages for exceptions with
 *                             general error codes (8, 10, 11, 12, 13 and 17)
 *                22.11.2004 - Output has been properly formatted and
 *                             additional registers (segment selectors
 *                             and control registers) have been included.
 *                29.10.2004 - The handler routine has been modified
 *                             to provide as much information as possible
 *                             In the case of #PF, a diagnostic message will
 *                             be displayed based on the error code.
 *                20.12.2003 - Ported from original Oberon implementation (flouw@cs.sun.ac.za)
 */
#include "include/asm.h"
#include "include/error.h"
#include "include/trace.h"
#include "include/i386.h"
#include "include/i8259.h"
#include "include/exceptions.h"

/*
 * A total of 20 exceptions are currently in use by Intel. According to the
 * Pentium III/IV datasheets, exception 1 (single step debug exception) is now
 * classified as reserved. Exception 9 (coprocessor segment overrun) is
 * not supported beyound the 80386 family. Also note that the Machine Check
 * Architecture exceptions are not fully supported (MCA registers are neither
 * retrieved nor interpreted when #MC is generated).
 */
#define MAX_EXCEPTIONS 20

/* ----- Page fault error code masks ------------------------------------------------------------ */
#define PF_P  0x00000001
#define PF_WR 0x00000002
#define PF_US 0x00000004

/* ---- General error code masks ---------------------------------------------------------------- */
#define ER_EXT      0x00000001
#define ER_IDT      0x00000002
#define ER_TI       0x00000004
#define ER_SELECTOR 0x0000fff8

static const char *exceptions[MAX_EXCEPTIONS] = {"Division by zero",
                                                 "Debug",
                                                 "NMI Interrupt",
                                                 "Breakpoint (int 0x03)",
                                                 "Overflow (into)",
                                                 "BOUND range exceeded",
                                                 "Invalid opcode",
                                                 "Device not available",
                                                 "Double Fault",
                                                 "Coprocessor segment overrun",
                                                 "Invalid TSS",
                                                 "Segment not present",
                                                 "Stack segment",
                                                 "General protection fault",
                                                 "Page fault",
                                                 "RESERVED",
                                                 "Floating-point error",
                                                 "Alignment check",
                                                 "Machine check",
                                                 "SIMD floating-point exception"};

unsigned char exception_handler(cpu_state *state, int exception) {
  printk("Exception %d - ", exception);
  if ((exception >= 0) && (exception < MAX_EXCEPTIONS))
    printk("%s\n", exceptions[exception]);
  else
    printk("RESERVED\n");
  /* ----- General-purpose registers ------------------------------------------------------------ */
  printk("eax: %#.8x, ebx: %#.8x, ecx: %#.8x, edx: %#.8x\n",
         state->eax, state->ebx, state->ecx, state->edx);
  printk("esp: %#.8x, ebp: %#.8x, esi: %#.8x, edi: %#.8x\n",
         state->kernel_esp, state->ebp, state->esi, state->edi);
  /* ----- Segment selectors -------------------------------------------------------------------- */
  printk("cs: %#.4hx, ds: %#.4hx, es: %#.4hx, fs: %#.4hx, gs: %#.4hx, ss: %#.4hx\n",
          cs(), ds(), es(), fs(), gs(), ss());
  /* ----- Special registers -------------------------------------------------------------------- */
  if ((state->cs & 03) == 03)
    printk("process esp: %#.8x, process ss: %#.4x, ", state->user_esp, state->user_ss);
  printk("eip: %#.8x, eflags: %#.8x\n", state->eip, state->eflags);
  printk("cr0: %#.8x, cr2: %#.8x, cr3: %#.8x\n", cr0(), cr2(), cr3());
  /* ----- Additional information --------------------------------------------------------------- */
  switch (exception) {
    case 14:
      printk("Possible cause: ");
      if ((state->error_code & PF_US) != 0)
        printk("A user-level task attempted");
      else
        printk("A supervisor-level task attempted");
      if ((state->error_code & PF_WR) != 0)
        printk(" a write operation to a page/page directory");
      else
        printk(" a read operation from a page/page directory");
      if ((state->error_code & PF_P) != 0)
        printk(" resulting in a page access violation\n");
      else
        printk(" that is marked as not-present\n");
      break;
    case 8:
    case 10:
    case 11:
    case 12:
    case 13:
    case 17:
      printk("Possible cause: ");
      if ((state->error_code & ER_EXT) != 0)
        printk("An external event");
      else
        printk("An internal program event");
      printk(" associated with the");
      if ((state->error_code & ER_IDT) != 0)
        printk(" IDT");
      else {
        if ((state->error_code & ER_TI) != 0)
          printk(" LDT");
        else
          printk(" GDT");
      }
      printk(" (entry %d)\n", (state->error_code & ER_SELECTOR) >> 3);
      break;
  }

  /* ----- The kernel will always reschedule after an exception --------------------------------- */
  return 1;
}

void exceptions_initialize() {
  int i;

  for (i = 0; i < IRQ0; i++) {
    if (i8259_install_interrupt_handler(i, exception_handler, 0) != OK)
      printk("[exceptions_initialize] error installing exception handler %d\n", i);
  }
}
