Project Description
The format of the input to the compiler (a simple language called PL) is described by the following EBNF. (Lines that were modified indicated by <-- NEW followed by the modification date.) 

Program = Block ".".
Block = "begin" DefinitionPart StatementPart "end".
DefinitionPart = {Definition ";"}.
Definition = ConstantDefinition | VariableDefinition | ProcedureDefinition.
ConstantDefinition = "const" ConstantName "=" Constant.
VariableDefinition = TypeSymbol variableList |
  TypeSymbol "array" VariableName "[" Constant "]". <-- NEW (17/8)
TypeSymbol = "integer" | "boolean".
VariableList = VariableName {"," VariableName}.
ProcedureDefinition = "proc" ProcedureName Block.
StatementPart = {Statement ";"}.
Statement = EmptyStatement | ReadStatement | WriteStatement |
  AssignmentStatement | ProcedureStatement | IfStatement |
  DoStatement.
EmptyStatement = "skip".
ReadStatement = "read" VariableAccessList.
VariableAccessList = VariableAccess {"," VariableAccess}.
WriteStatement = "write" ExpressionList.
ExpressionList = Expression {"," Expression}.
AssignmentStatement = VariableAccessList ":=" ExpressionList.
ProcedureStatement = "call" ProcedureName.
IfStatement = "if" GuardedCommandList "fi".
DoStatement = "do" GuardedCommandList "od".
GuardedCommandList = GuardedCommand {"[]" GuardedCommand}.
GuardedCommand = Expression "->" StatementPart.
Expression = PrimaryExpression {PrimaryOperator PrimaryExpression}.
PrimaryOperator = "&" | "|".
PrimaryExpression = SimpleExpression [RelationalOperator
  SimpleExpression].
RelationalOperator = "<" | "=" | ">".
SimpleExpression = ["-"] Term {AddingOperator Term}.
AddingOperator = "+" | "-".
Term = Factor {MultiplyingOperator Factor}.
MultiplyingOperator = "*" | "/" | "\".
Factor = Constant | VariableAccess | "(" Expression ")" | "~" Factor.
VariableAccess = VariableName [IndexedSelector].
IndexedSelector = "[" Expression "]".
Constant = Numeral | ConstantName.
Numeral = Digit {Digit}.
Name = Letter {Letter | Digit}.

Here is some additional information not covered by the EBNF specification. Apart from certain conventions such as the length of names, the meaning (semantics) of the language is described informally. Type checking is an important part of semantic analysis for which the symbol table is essential. 

Identifiers are case sensitive and can be at most 32 characters long. Integers are represented as 32-bit signed values. To save memory, Boolean values are usually represented as 8-bit integer numbers (0=false, 1=true). However, to simplify things, they may be implemented as 32-bit integers. The compiler should recognise two predefined constants false (value 0) and true (value 1). Comments, which may be nested, are marked by the symbols "(*" and "*)". A multiple assignment (such as x, y := y, x) is executed by first evaluating all expressions in the expression list (right side) from left to right and then assigning them in the same order to the list of variables in the variable list (left side). An if-fi command is executed by evaluating each guard until the first one is found that is true. The statement sequence following that guard is then executed and the if-fi command terminates. If all guards are false, the if-fi command is aborted. A do-od loop is executed by evaluating each guard until the first one is found that is true. The statement sequence following that guard is then executed and the loop is repeated. It terminates when all its guards are false. 

Here are some examples of LF programs: 

(* GCD *)
begin
  integer x, y;

  read x, y;
  do x < y -> y := y - x;
  [] y < x -> x := x - y;
  od;
  write x, y; (* x = y = GCD(x, y) *)
end.

In Euclid's algorithm for computing the GCD of two integers, the loop terminates when all its guards are false, that is when x = y. 
(* Linear search *)
begin
  const n = 10; integer array A[n];
  integer x, i; boolean found;

  proc Search
  begin integer m;
    i, m := 0, n;
    do i < m ->
      if A[i] = x -> m := i;
      [] ~(A[i] = x) -> i := i + 1;
      fi;
    od;
    found := A[i] = x;
  end;

  (* read table *)
  i := 0;
  do ~(i = n) -> read A[i]; i := i + 1; od;
  (* test search *)
  read x;
  do ~(x = 0) ->
    call Search;
    if found -> write x, i;
    [] ~found -> write x;
    fi;
    read x;
  od;
end.

The array A[] has 10 elements, with indexes ranging from 0 to 9. Test code is provided to initialise the table with 10 numbers and then search for a given number. 
Project Documentation
All large software projects need documentation. Write a document that describes the design of your symbol table. Diagrams should be included to explain the data structure(s) involved. Also include a detailed description of the interface between the symbol table and the rest of the compiler. Any word processor may be used to typeset the document. You should pay attention to writing style and spelling, because marks will be allocated for the readability of the document. 
The following sections should be included: (1) Introductory description of the problem and the goal of the symbol table, (2) Brief discussion of various design alternatives, (3) Detailed description and motivation of the chosen design, (4) The interface presented by the symbol table, (5) Possible extentions to accommodate additional language features such as procedure parameters and structured types such as records. The document must be printed on A4 paper and handed in on or before 17h00 on Friday 2 September. 

Test programs
Test programs for Demo 1: 
begin (* test 1 (correct) *)
  const MAX = 2147483647;
  integer x, y; 
  
  (* this is a (* nested *) comment *)
  x := MAX; y := -(MAX + 1);
  x, y := y, x;
  write x; write y;
end.

begin (* test 2 (incorrect) *)
  (* this is a (* bad *) comment )*
end.

begin (* test 3 (correct) *)
  integer array X[2];

  proc swap
  begin
    integer t;

    t := X[0]; X[0] := X[1]; X[1] := t; skip;
  end;

  X[0] := 10; X[1] := 11;
  call swap;
  X[0], X[1] := X[1]+1, X[0];
  write +X[0] - X[1];
end.

begin (* test 4 (incorrect) *)
  integer array X[2];

  (* there should be no semicolon after the procedure name *)
  proc swap;
  begin
    integer t;

    t := X[0]; X[0] := X[1]; X[1] := t;
  end;

  X[0] := 10; X[1] := 11;
  call swap;
end.

begin (* test 5 (correct) *)
  const five = 5;
  boolean ok;
  integer p, q
  
  p := 1; q := 3;
  ok := true | ~(p < q);
end.

begin (* test 6 (incorrect) *)
(* there should be a dot after end *)
end

begin (* test 7 (correct) *)
  integer x, y, r;

  x := 3; y := 4;
  if (x < y) & true -> r := 10;
  [] false | (x > y) -> r := 11;
  [] x = y -> r := -12-3*2-1;
  [] true -> skip;
  fi;
end.

begin (* test 8 (incorrect) *)
  integer x, y;

  x := 3; y := 4;
  if x < y -> skip;
  [] ~(x < y) -> skip (* missing semicolon *)
  if (* typo: *)
end.

begin (* test 9 (correct) *)
  integer a012345678901234567890123456789b;
  
  a012345678901234567890123456789 := 1;
end.

begin (* test 10 (incorrect) *)
  (* name longer than 32 characters *)
  integer a012345678901234567890123456789bc;
  
  skip;
end.

