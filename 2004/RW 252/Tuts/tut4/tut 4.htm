<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0046)http://www.cs.sun.ac.za/~eloff/rw252/tut4.html -->
<HTML><HEAD><TITLE>Computer Science 252</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1"><LINK 
media=screen href="tut 4_files/style.css" type=text/css rel=stylesheet>
<META content="MSHTML 6.00.2900.2180" name=GENERATOR></HEAD>
<BODY bgColor=#ffffff background="">
<TABLE cellSpacing=12 cellPadding=0 width="100%">
  <TBODY><!-- Banner -->
  <TR>
    <TD class=banner colSpan=3>Computer Science 252 - Low Level Programming 
  </TD></TR><!-- Navigation bar (left) -->
  <TR>
    <TD class=navbar vAlign=top>
      <DIV class=navhead>CS252 </DIV>
      <DIV class=navtext><A class=navref 
      href="http://www.cs.sun.ac.za/~eloff/rw252/index.html">Home</A> <A 
      class=navref href="http://www.cs.sun.ac.za/~eloff/rw252/exams.html">Tests 
      and Examinations</A> <A class=navref 
      href="http://www.cs.sun.ac.za/~eloff/rw252/schedule.html">Class 
      Schedule</A> <A class=navref 
      href="http://www.cs.sun.ac.za/~eloff/rw252/outline.html">Course 
      Outline</A> <A class=navref 
      href="http://www.cs.sun.ac.za/~eloff/rw252/doc.html">Documentation and 
      Notes</A> <A class=navref 
      href="http://www.cs.sun.ac.za/~eloff/rw252/tuts.html">Tutorials</A> <A 
      class=navref 
      href="http://www.cs.sun.ac.za/~eloff/rw252/reading.html">Further 
      Reading</A> <A class=navref title=eloff@cs.sun.ac.za 
      href="mailto:eloff@cs.sun.ac.za">E-mail the Lecturer</A> </DIV></TD><!-- main text: centre bar -->
    <TD class=MAIN vAlign=top>
      <H1>Tutorial 4 - Floating-point Emulation</H1>
      <H2>Description</H2>Not all CPUs support floating point operations. The 
      first processors within the Intel family (8088/8086, 80286 and 80386) 
      required special processors called co-processors (8087, 80287 and 80387) 
      that contained the floating point unit (FPU). The FPU was first 
      intergrated into the 80486 processor. FPU's were expensive and often not 
      an option a typical user would consider when purchasing a PC. 
      <P>However, floating point calculations play an important role in 
      computing, whether you need to balance a budget or calculate the orbit of 
      a satellite. Today, many embedded processors do not possess a FPU, yet 
      still require processing floating point data. This is usually achieved by 
      emulating floating point operations. The IEEE released a standard (IEEE 
      Std 754) that defines the format for binary floating point representation 
      of single, double and extended precision numbers. Today, most FPUs and 
      programming languages adheres to this standard. 
      <P>The IEEE standard defines three formats: 32-bit single precision, 
      64-bit double precision and 80-bit extended precision reals. The layout of 
      a 32-bit real and examples of some values are illustrated below: 
      <P>
      <TABLE cellPadding=3 width="100%" border=0>
        <TBODY>
        <TR>
          <TD align=middle width="5%" bgColor=#c0c0c0>Value
          <TD>
          <TD align=middle width="10%" bgColor=#c0c0c0>31 (Sign)</TD>
          <TD align=middle width="25%" bgColor=#c0c0c0>30..23 (Biased 
          Exponent)</TD>
          <TD align=middle width="60%" bgColor=#c0c0c0>22..0 (Fraction)</TD></TR>
        <TR>
          <TD align=middle width="5%" bgColor=#ded5d3>-0
          <TD>
          <TD align=middle width="10%" bgColor=#ded5d3>Sign = 1</TD>
          <TD align=middle width="25%" bgColor=#ded5d3>Exponent = 0</TD>
          <TD align=middle width="60%" bgColor=#ded5d3>Fraction = 0</TD></TR>
        <TR>
          <TD align=middle width="5%" bgColor=#ded5d3>+0
          <TD>
          <TD align=middle width="10%" bgColor=#ded5d3>Sign = 0</TD>
          <TD align=middle width="25%" bgColor=#ded5d3>Exponent = 0</TD>
          <TD align=middle width="60%" bgColor=#ded5d3>Fraction = 0</TD></TR>
        <TR>
          <TD align=middle width="5%" bgColor=#ded5d3>-Infinity
          <TD>
          <TD align=middle width="10%" bgColor=#ded5d3>Sign = 1</TD>
          <TD align=middle width="25%" bgColor=#ded5d3>Exponent = 255</TD>
          <TD align=middle width="60%" bgColor=#ded5d3>Fraction = 0</TD></TR>
        <TR>
          <TD align=middle width="5%" bgColor=#ded5d3>+Infinity
          <TD>
          <TD align=middle width="10%" bgColor=#ded5d3>Sign = 0</TD>
          <TD align=middle width="25%" bgColor=#ded5d3>Exponent = 255</TD>
          <TD align=middle width="60%" bgColor=#ded5d3>Fraction = 
        0</TD></TR></TBODY></TABLE>
      <P>The sign bit determines whether the value represented by the real 
      number is positive or negative. The exponent does not have a sign bit. 
      Instead, it is represented as a positive value and called a biased 
      exponent (also called excess notation). Subtracting the bias value from 
      the exponent yields its actual value. The bias for 32-bit single precision 
      reals is 127. For example, a biased exponent of 129 in fact represents the 
      exponent 2 (129-127) while a negative exponent such as -3 has a biased 
      representation of 124 (-3+127). 
      <P>Floating point numbers are based on scientific notation. This means all 
      fractions are preceded by an implied "1" or "0" before the decimal point. 
      Literature sometimes refer to this as the J-bit or leading bit (or leading 
      1). It is always present, but never explicitly stored. The value of the 
      J-bit may be set to 1 if either the fraction or biased exponent is 
      non-zero. 
      <H4>Example value</H4>Consider the decimal value 120.75 which may be 
      expressed as 1.2075E2 in scientific decimal notation and as 1.11100011E110 
      in scientific binary. Making the exponent biased results in the value 
      1.11100011E10000101. The final 32-bit representation for the real value 
      becomes: 
      <TABLE cellPadding=3 width="100%" border=0>
        <TBODY>
        <TR>
          <TD align=middle width="10%" bgColor=#ded5d3>0 (Sign)</TD>
          <TD align=middle width="25%" bgColor=#ded5d3>10000101 (Biased 
            Exponent)</TD>
          <TD align=middle width="60%" bgColor=#ded5d3>11100011000000000000000 
            (Fraction)</TD></TR></TBODY></TABLE>
      <H4>Example calculation: 32-bit addition</H4>Consider the addition of 
      133.6 and 4.5. The value 133.6 in scientific decimal notation is 1.336E2, 
      its binary representation (without a biased exponent) is 
      1.0000101100110011001101E111 or 1.0000101100110011001101E10000110 (with 
      biased exponent). If we examine the section that represents the fraction 
      0.6, we find that it is in fact equal to 0.100110011001101 or 0.600006103 
      (2<SUP>-1</SUP>+2<SUP>-4</SUP>+2<SUP>-5</SUP>+2<SUP>-8</SUP>+2<SUP>-9</SUP> 
      +2<SUP>-12</SUP>+2<SUP>-13</SUP>+2<SUP>-15</SUP>), the closest 
      representation to 0.6 that can fit into the fraction. The binary 
      representation for 4.5 is 1.001E10000001 (with biased exponent). The 
      leading 1 is discarded when the real value is physically stored, so the 
      two values in IEEE, 32-bit single precision format becomes: 
      <TABLE cellPadding=3 width="100%" border=0>
        <TBODY>
        <TR>
          <TD align=middle width="10%" bgColor=#ded5d3>0 (Sign)</TD>
          <TD align=middle width="25%" bgColor=#ded5d3>10000110 (Biased 
            Exponent = 134)</TD>
          <TD align=middle width="60%" bgColor=#ded5d3>00001011001100110011010 
            (Fraction)</TD></TR>
        <TR>
          <TD align=middle width="10%" bgColor=#ded5d3>0 (Sign)</TD>
          <TD align=middle width="25%" bgColor=#ded5d3>10000001 (Biased 
            Exponent = 129)</TD>
          <TD align=middle width="60%" bgColor=#ded5d3>00100000000000000000000 
            (Fraction)</TD></TR></TBODY></TABLE>
      <P>After expanding the real values and breaking them into their 3 
      components (sign exponent and fraction) we find for 133.6: 
      <TABLE cellPadding=3 width="100%" border=0>
        <TBODY>
        <TR>
          <TD align=middle width="10%" bgColor=#ded5d3>0 (Sign)</TD>
          <TD align=middle width="25%" bgColor=#ded5d3>00000111 (Exponent)</TD>
          <TD align=middle width="60%" 
            bgColor=#ded5d3>100001011001100110011010 (Fraction with leading 
        1)</TD></TR></TBODY></TABLE>and for 4.5: 
      <TABLE cellPadding=3 width="100%" border=0>
        <TBODY>
        <TR>
          <TD align=middle width="10%" bgColor=#ded5d3>0 (Sign)</TD>
          <TD align=middle width="25%" bgColor=#ded5d3>00000010 (Exponent)</TD>
          <TD align=middle width="60%" 
            bgColor=#ded5d3>100100000000000000000000 (Fraction with leading 
        1)</TD></TR></TBODY></TABLE>
      <P>After making the exponents equal by shifting the fractions in 
      incrementing the exponents (00000111), the fractions become: 
      <TABLE cellPadding=3 width="100%" border=0>
        <TBODY>
        <TR>
          <TD align=middle width="100%" 
            bgColor=#ded5d3>100001011001100110011010</TD></TR>
        <TR>
          <TD align=middle width="100%" 
            bgColor=#ded5d3>000001001000000000000000</TD></TR></TBODY></TABLE>and 
      since both numbers are positive, they can simply be added, yielding 
      <TABLE cellPadding=3 width="100%" border=0>
        <TBODY>
        <TR>
          <TD align=middle width="100%" 
            bgColor=#ded5d3>100010100001100110011010</TD></TR></TBODY></TABLE>Because 
      some calculations may leave a fraction exceeding 24-bits, the 
      normalization procedure must ensure that the left most byte (bits 31..24) 
      of the fraction does not contain any 1s. It is also possible that the 
      result lies within bits 22..00. In this case, the value must be shifted to 
      the left until a 1 is in bit 23. The exponent and fraction is unchanged 
      after normalization. The final result after combining the sign, exponent 
      and fraction is 01000011000010100001100110011010 or 138.100006103. 
      <H3>Algorithms</H3>
      <H4>Addition</H4><PRE>1 Expand each 32-bit real (r1, r2) into its sign (s1, s2), 
  exponent (e1, e2) and fraction (f1, f2)
2 WHILE e1 &lt; e2 DO
    Increment e1 and divide f1 by 2
  END;
  WHILE e2 &lt; e1 DO
    Increment e2 and divide f2 by 2
  END;
3 Let e3 be the common exponent 
4 IF r1 is negative THEN negate f1 END;
  IF r2 is negative THEN negate f2 END;
5 Add the f1 and f2 to form a new fraction f3
6 IF f3 &lt; 0 THEN
    negate f3 and set s3 to reflect a negative result 
  ELSE set s3 to reflect a positive result END
7 Normalize s3, e3, f3
8 Combine s3, e3 and f3 to form a 32-bit real value
  </PRE>
      <H4>Normalization for 32-bit reals</H4><PRE>1 IF fraction = 0 THEN exit END
2 WHILE the left-most part of the fraction (bits 31..24) contains a non-zero bit DO
    Shift the fraction 1 position to the right
    Increment the exponent
  END
3 WHILE bit 23 (24th bit) # 1 DO
    Shift the fraction 1 position to the left
    Decrement the exponent
  END
  </PRE>
      <H2>Instructions</H2>
      <OL>
        <LI>Download the tutorial skeleton <A 
        href="http://www.cs.sun.ac.za/~eloff/rw252/tut4.tar">here</A> 
        <LI>Create a working directory on your Linux account and extract the tar 
        file by executing the command <CODE>tar -xvf tut4.tar</CODE> at the 
        command prompt inside a terminal or console. 
        <LI>The tar-file contains a number of files, including a makefile and 
        <I>C</I> program that can be used for testing. Open the file named 
        <CODE>tut4.h</CODE>. It contains only one function prototype: 
        <UL>
          <LI><CODE>extern void addf(float a, float b, float *x)</CODE><BR>This 
          function adds the contents of <CODE>a</CODE> and </CODE>b</CODE> and 
          returns the result through a reference parameter in <CODE>x</CODE>. 
          </LI></UL>
        <LI><B>Note that in some cases your answers may be reported as being 
        incorrect when compared to the results generated by the CPU's 
        floating-point unit. The reason for this is that all floating-point 
        operations are performed using 80-bit extended precision, allowing for 
        more accurate calculations. Furthermore, the rounding mode also has an 
        effect on the final result. For example, using the algorithm we present 
        here, adding 3.7 and 4.1 will produce an answer of 7.7999991 while the 
        CPU will report 7.80000019 as the correct answer. 
        <P>Most of the examples have been chosen to so that your results will 
        exactly match those generated by the CPU. </B></P>
        <LI>You can obtain information about the nasm assembler by executing the 
        command <CODE>info nasm</CODE> at the command prompt. 
  </LI></OL></TD></TR></TBODY></TABLE></BODY></HTML>
